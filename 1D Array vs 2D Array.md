## 1. 1D Array vs 2D Array

### <1D or 2D array, what's faster?>

##### Stackoverflow에 올라온 Pixelchemist의 답변

##### :one:1 차원 배열과 2차원 배열 중 무엇이 더 빠른가?
###### 고밀도의 행렬의 경우 1차원의 접근 방식은 더 나은 메모리 지역성(memory alloccation)과 더 적은 메모리 할당 및 해제 오버헤드를 제공하기 때문에, 더 빠를 수 있다.

##### :two: 1차원 배열과 2차원 배열 중 무엇이 더 작은가?(더 적은 메모리를 차지하는가?)
###### 1차원 동적 할당의 경우 2차원 방식의 접근 보다 메모리를 덜 차지한다. 2차원의 경우 더 많은 메모리 할당을 필요로 한다.

##### :question: 질문자의 코멘트
###### 1차원 배열의 인덱스들을 다시 계산하는 것(y + x*n)이 (x,y)의 2차원 배열 보다 더 느리지 않을까?
###### 인덱스를 계산하는 것은 큰 성능 차이를 발생시키지 않음.

##### :three: CPU 캐시 관련 문제
###### 동적 배열의 2차원 접근 방식이 왜 단순하거나 작은 행렬에 부적합한가?
###### :heavy_exclamation_mark: 정적 2차원 배열의 경우 연속된 메모리 블록이므로 논외로 한다.

##### <예제 코드>
![image](https://user-images.githubusercontent.com/52204522/103352083-981f7a80-4ae8-11eb-8fec-8c7a546a31a5.png)

##### 위의 코드로 살펴보는 단점들

###### :one: Memory Locality(메모리 지역성)

###### 위의 코드에서 4개의 포인터를 위한 하나의 블록을 할당하고, 4개의 정수들을 위한 4개의 블록을 할당한다. 이 때, 모든 할당들은 연관되어 있지 않고 따라서 임의의 메모리에 위치 하게 된다.

###### 아래 그림을 살펴보면,
##### 왼쪽의 실제 2D 접근 방식의 경우:
######        *■ 보라색 사각형의 경우 p 자체가 차지하는 메모리 위치이다.*
######        *■ 초록색 사각형들의 경우 p가 가리키는 메모리 영역을 구성한다.( 4 x int* )*
######        *■ 4개의 연속된 파란 사각형들은 초록색 영역의 각 int*(int 포인터)가 가리키는 것들이다.*

##### 오른쪽의 1차원으로 매핑된 2차원 케이스의 경우:
######       *■ int* 를 위해 필요한 공간의 경우 초록색 공간 하나만 있으면 된다.*
######       *■ 파란색 사각형들은 행렬의 모든 요소( 16 x int )를 위한 메모리 영역을 이룬다.*

![image](https://user-images.githubusercontent.com/52204522/103353019-0f560e00-4aeb-11eb-8a25-9b98d01de3da.png)

###### 이러한 예시에서 캐싱으로 인해 왼쪽의 방식을 사용할 경우, 오른쪽 방식(연속적인 저장 패턴)보다 성능이 저하될 수 있음을 의미한다.

###### cache line을 "한 번에 캐시에 전송가능한 데이터의 양" 이라고 하고, 프로그램이 전체 행렬에 차례로 접근한다고 상상해보자.

###### 32비트 값의 4 x 4 행렬이 올바르게 정렬된 경우에 64바이트 cache line(전형적인 값)을 가진 프로세서가 데이터를 한번에 접근할 수 있다(one-shot). 처리를 시작하고 캐시에 데이터가 없을 경우 *캐시 미스*가 발생하고, 데이터를 메인 메모리로부터 가져오게 된다. 이러한 로드(캐시에 적재)는 연속으로 적절하게 정렬된 경우에만 cache line에 딱 들어맞기 때문에 전체 행렬을 한 번에 가져올 수 있다. 이렇게 연속적으로 올바르게 정렬된 경우에는 해당 데이터를 처리하는 동안 더 이상의 미스가 발생하지 않을 것이다.

###### 각 행/열의 관련 없는 위치가 있는 동적 "실제 2차원" 시스템의 경우 프로세서가 모든 메모리 위치를 개별적으로 로드해야 한다. 오직 64바이트만 필요하더라도 4개의 관련 없는 메모리 위치에 대해 4개의 캐시 라인을 로드하면 최악의 경우 256바이트를 전송하고 75%의 처리량 대역폭을 낭비하게 된다. 2차원 구성표를 사용하여 데이터를 처리할 경우 첫 번째 요소에서 캐시 누락이 다시 발생하게 된다. 그러나 이제 다른 모든 행은 첫 번째 행과 인접하지 않고 메모리 내의 다른 곳에 위치하기 때문에 기본 메모리에서 첫 번째 로드 후 첫 번째 행/열만 캐시에 있게 되고, 새 행/열에 도달하면 즉시 캐시 누락이 발생하고 기본 메모리에서 다음 로드가 수행된다.

##### 즉, 2차원 패턴은 캐시 미스 가능성이 높고, 1차원의 경우에는 데이터의 인접성(지역성)으로 인해 더 나은 성능을 제공할 수 있다.

###### :two: 빈번하게 일어나는 할당과 해제

#######


## 참고 자료

##### [1D or 2D array, what's faster?](https://stackoverflow.com/questions/17259877/1d-or-2d-array-whats-faster/17260533)
##### [1D vs 2D Arrays, the Performance Reality](http://pointlessdiversions.blogspot.com/2012/05/1d-vs-2d-arrays-performance-reality.html)
##### [캐쉬 프렌들리 코드 예시](http://lab.gamecodi.com/board/zboard.php?id=GAMECODILAB_QnA_etc&no=5543)

